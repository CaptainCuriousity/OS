1. Взаимодействие процессов через разделяемую память:

a. Создайте регион памяти размером в одну страницу при помощи
	системного вызова mmap(2), таким образом, чтобы он был общим для
	двух процессов.

b. Пусть один процесс непрерывно пишет целые числа (типа unsigned int)
	от 0 до максимального значения (0, 1, … max) в данный регион. Когда он
	доходит до конца региона, сразу начинает писать сначала.

c. Другой процесс читает из этого региона и проверяет, что числа идут
	последовательно. При обнаружении сбоя последовательности, выводит
	соответствующее сообщение в консоль.

d. Объясните причину таких сбоев.

e. Как вы думаете, что можно было бы сделать чтобы этих сбоев не было?


Progress:
a. Done.
b. Program has been made.
c. Another program has been made
d. Reason: writer writes faster than reader reads (or vice-versa: reader reads faster)
e. Use pipe. Or create big linear buffer which takes info from first process and then gives this info
to another process.

Problem: something goes wrong on my system. When I get bus error, process stops execution and
that's it


Conspect: 
Палочка (|) помогает перенаправить stdout в stdin другого процесса.
pipe.    ^

Я смогу видеть данные из анонимного региона только в том случае, если я я пытаюсь достучаться до общей
памяти при помощи форка
Теперь пишем программу, как в этой задаче.
Нагло ворую прогу у лектора...

Далее, есть другая программа, кто точно так же открывается этот же файл, но сей раз он читается.

пытаемся как-то синхронизировать эту фигню. Придумываем pipe.

Проблемы изначальная заключалась в том, что запись шла быстрее чтения (или наоборот)
Смысл заключается в том, что процессы друг с другом взаимодействуют и блокируют друг друга в случае чего.

Создаётся сискол syspipe, который создаёт буфер, пару указателей (pipe_read(), pipe_write())
Эти функции будут уметь работать с нашим буфером. sys_pipe() помимо прочего
будет создавать inode с этими функциями read/write, стуктуру file.
pipe() возвращает 0 - вывод, 1 - ввод. 

Теперь задача: а как взаимодействовать с другим процессом, ведь pipe есть только в одном из них?
Базовое решение - fork(). 

При открытии файла создаётся новый (3, 4, ...) дескриптор.
popen() делает форк. После него появляется новый процесс, он копирует всё из старого процесса.
r говорит о том, что я планирую читать данные из процесса.
w соответственно о том, что я печатаю в др. процесс.
popen Рутману не нравится. Например, если программа отработала неправильно, 
то в другом потоке не будет понятно, что она отработала неправильно. Реализация popen не додумана до конца.
Приходится анализировать возвращённое значение с помощью макросов (WEXITSTATUS(exit_status))
popen очень удобен, позволяет использовать одну и ту же функцию несколько раз. (ну меньше повторяться придётся)

Как хранятся файловые дескрипторы (чтоб раз и навсегда) - в task есть массив files, там хранятся открытые файлы.
0: stdin, 1: stdout, 2: stderr.

Ещё раз, суть pipe:
перенаправляется вывод в буфер (то есть файловый дескриптор stdout процесса-отправителя посылает свои данные в pipe). 
Или иначе: stdout одного процесса связывается c stdin другого через pipe.
pipe'ы - это файлы (цитата)

